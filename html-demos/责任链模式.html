<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    class ResChain {
      /**
       * æŒ‰é¡ºåºå­˜æ”¾é“¾çš„key
       */
      keyOrder = []
      /**
       * keyå¯¹åº”çš„å‡½æ•°
       */
      key2FnMap = new Map()
      /**
       * æ¯ä¸ªèŠ‚ç‚¹éƒ½å¯ä»¥æ‹¿åˆ°çš„å¯¹è±¡
       */
      ctx = {}
      constructor(ctx) {
        this.ctx = ctx
      }

      // è¿™é‡Œç”¨keyæ¥æ ‡è¯†å½“å‰callbackçš„å”¯ä¸€æ€§ï¼Œåé¢é‡å¤æ·»åŠ å¯ä»¥åŒºåˆ†ã€‚
      add(key, callback) {
        if (this.key2FnMap.has(key)) {
          throw new Error(`Chain ${key} already exists`)
        }

        this.keyOrder.push(key)
        this.key2FnMap.set(key, callback)
        return this
      }

      async run() {
        let index = -1
        const dispatch = (i) => {
          if (i <= index) {
            return Promise.reject(new Error('next() called multiple times'))
          }

          index = i
          const fn = this.key2FnMap.get(this.keyOrder[i])
          console.log("ğŸš€ ~ dispatch ~ fn:", fn)
          if (!fn) {
            return Promise.resolve(void 0)
          }

          return fn(this.ctx, dispatch.bind(null, i + 1))
        }

        return dispatch(0)
      }
    }

  </script>
  <script>
    const ctx = {
      // è¡¨å•é¡¹
      model: {
        name: 'gg',
        phone: '',
      },
      // é”™è¯¯æç¤º
      error: '',
      // æ˜¯å¦ä¸­æ–­
      interrupt: false,
    }

    function test() {
      const resChain = new ResChain(ctx);

      resChain.add('æ ¡éªŒname', ({ model, ...res }, next) => {
        const { name = '' } = model
        if (name === '') {
          ctx.error = 'è¯·å¡«å†™name';
          ctx.interrupt = true;
          return;
        }
        next();
      })

      resChain.add('æ ¡éªŒphone', ({ model }, next) => {
        const { phone = '' } = model
        if (phone === '') {
          ctx.error = 'è¯·å¡«å†™æ‰‹æœºå·';
          ctx.interrupt = true;
          return;
        }
        next();
      })
      // æ‰§è¡Œè´£ä»»é“¾
      resChain.run();
      // å¦‚æœéœ€è¦ä¸­æ–­ï¼Œåˆ™æç¤º
      if (resChain.ctx.interrupt) {
        alert(resChain.ctx.error);
        return;
      }

    }
    test()


    function pipe(fns = []) {
      return (data) => {
        return fns.reduce((prev, curr) => {
          return prev.then(curr)
        }, Promise.resolve(data))
      }
    }


  </script>
</body>

</html>